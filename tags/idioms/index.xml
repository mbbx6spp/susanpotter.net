<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>idioms on Susan Potter</title>
    <link>/tags/idioms/</link>
    <description>Recent content in idioms on Susan Potter</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Jan 2007 18:48:00 -0600</lastBuildDate>
    
	<atom:link href="/tags/idioms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ruby Idioms, Part 7</title>
      <link>/snippets/ruby-idioms-part-7/</link>
      <pubDate>Wed, 24 Jan 2007 18:48:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-7/</guid>
      <description>This idiom I have seen a little more in Rails than I have seen in Ruby, but I am putting it in this Ruby Idioms series anyway.
 First off, most of you will know by know that you can &amp;#34;transparently&amp;#34; provide a method in Ruby a Hash. What do I mean by &amp;#34;transparently&amp;#34;? Well have a look at the code example below:
user = User.find(:first, :include =&amp;gt; :preferences)   The last argument is actually a Hash even though you do not see the curly braces at all.</description>
    </item>
    
    <item>
      <title>Ruby Idioms, Part 6</title>
      <link>/snippets/ruby-idioms-part-6/</link>
      <pubDate>Tue, 23 Jan 2007 22:28:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-6/</guid>
      <description>Tonight I remembered couple more idioms in Ruby and felt compelled to share.
 In Javafied Ruby code (below) we often see something like the following:
if something for role in user.roles return true if @@roles.include? role end end   Now when I first started writing Ruby code almost 3 years ago, I thought looping through a collection like above was the nicest way. I quickly found Ruby like the following snippet in code I inherited:</description>
    </item>
    
    <item>
      <title>Ruby Idioms, Part 5</title>
      <link>/snippets/ruby-idioms-part-5/</link>
      <pubDate>Mon, 22 Jan 2007 19:43:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-5/</guid>
      <description>Some of you may say this isn&amp;#39;t strictly an idiom, but it is dependent on Ruby&amp;#39;s core API and classes, so I have included it. Ranges are a very nice low-level abstraction and can save Ruby developers a lot of time for certain coding needs. In a previous idiom example on this blog I had a list of positive odd numbers under 7. Well typing this out by hand is hardly consuming so I typed [1, 3, 5] by hand.</description>
    </item>
    
    <item>
      <title>Ruby Idioms, Part 4</title>
      <link>/snippets/ruby-idioms-part-4/</link>
      <pubDate>Mon, 22 Jan 2007 19:36:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-4/</guid>
      <description>To splat or not to splat, that is the question.
 In Java to unpack an array&amp;#39;s values into separate variables you would need to do something like the following:
burgers = [:hamburger, :bocaburger, :gardenburger, :turkeyburger] t = burgers[0] u = burgers[1] v = burgers[2] w = burgers[3]   In the Ruby mindset this would look more like the following:
burgers = [:hamburger, :bocaburger, :gardenburger, :turkeyburger] t, u, v = *burgers # t=&amp;gt;:hamburger, u=&amp;gt; :bocaburger, v=&amp;gt;:gardenburger t, u, v, w = *burgers # t=&amp;gt;:hamburger, u=&amp;gt;:bocaburger, v=&amp;gt;:gardenburger, w=&amp;gt;:turkeyburger t, u, v, w, x = *burgers # t=&amp;gt;:hamburger, u=&amp;gt;:bocaburger, v=&amp;gt;:gardenburger, w=&amp;gt;:turkeyburger, x=&amp;gt;nil   Think of * (or splat) as the Ruby way of unpacking the elements of an Array into separate variables in Ruby.</description>
    </item>
    
    <item>
      <title>Ruby Idioms, Part 3</title>
      <link>/snippets/ruby-idioms-part-3/</link>
      <pubDate>Mon, 22 Jan 2007 19:32:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-3/</guid>
      <description>Now, probably the biggest difference after the syntax, and the non-static nature of Ruby for Java heads to get used to is that Ruby is an &amp;#34;expressionist&amp;#34; language. Meaning almost all statements in Ruby evaluates to a value, i.e. everything that reasonably can be is an expression in Ruby is. This is definitely not the way Java thinks or works. So this will take some adjusting to. Don&amp;#39;t worry I will show you an example.</description>
    </item>
    
    <item>
      <title>Ruby Idioms, Part 2</title>
      <link>/snippets/ruby-idioms-part-2/</link>
      <pubDate>Mon, 22 Jan 2007 19:21:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-2/</guid>
      <description>Now the &amp;#34;idiom&amp;#34; we will use is not specific to Ruby, since I am pretty sure Perl has one of the constructs we will use to solve the stated problem, but it is still idiomatic, since the majority of popular OO languages (static, dynamic or otherwise) do not have it (as far as I know). Also some consider this to be a sub-optimal idiom, because there is a terser way to do something like this.</description>
    </item>
    
    <item>
      <title>Ruby Idioms, Part 1</title>
      <link>/snippets/ruby-idioms-part-1/</link>
      <pubDate>Mon, 22 Jan 2007 19:16:00 -0600</pubDate>
      
      <guid>/snippets/ruby-idioms-part-1/</guid>
      <description>With more people moving to Ruby everyday from languages like Java, I wanted to create blog entries on the most common Ruby idioms (especially ones frequently found in Rails core or Rails application code) and briefly explain how to convert your Java mindset to Ruby (over time).
 This is the first installment.
 First let us inspect what we might do in Java (converted to Ruby syntax) when determining if a value passed in equals various fixed values:</description>
    </item>
    
  </channel>
</rss>