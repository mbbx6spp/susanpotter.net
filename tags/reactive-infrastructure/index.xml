<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reactive infrastructure on Susan Potter</title><link>/tags/reactive-infrastructure/</link><description>Recent content in reactive infrastructure on Susan Potter</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 04 Oct 2016 00:00:00 +0000</lastBuildDate><atom:link href="/tags/reactive-infrastructure/index.xml" rel="self" type="application/rss+xml"/><item><title>Functional and Reactive Operations</title><link>/talks/functional-and-reactive-operations/</link><pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate><guid>/talks/functional-and-reactive-operations/</guid><description>If we were starting greenfield development of a service or web application today we would likely employ a number of practices and design choices that are known to optimise application responsiveness, resiliency, elasticity, and/or composability. Delivering our reactive applications on top of predictable infrastructure will set our project up for success. Some of us don&amp;#39;t have that luxury. We must provision, deploy, and operationally maintain legacy monolithic Rails web applications and HTTP APIs that are hard to refactor without introducing new bugs, poorly performing, and struggle to meet user load/peak demand. Built during a prior era of the company where fast and loose practices were rewarded, startup cowboys delivered the first set of features promptly at the expense of subsequent velocity, long-term maintainability, and high risk deployments. When living in this reality, our infrastructure must be reliable or our application needs constant babysitting, leading to on-call fatigue and high staff turnover. The good news is there are core principles we can apply to produce more reproducible systems, failstop deployments, and consistent environment configurations to eliminate a large class of bugs inherent in legacy applications and minimize related business risks. This will be the focus of the session and applies to both greenfield and legacy cases. Code examples given using NixOS and Haskell, but focus remains on the underlying principles.</description></item></channel></rss>