<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>infrastructure on Susan Potter</title><link>/tags/infrastructure/</link><description>Recent content in infrastructure on Susan Potter</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 26 Apr 2019 00:00:00 +0000</lastBuildDate><atom:link href="/tags/infrastructure/index.xml" rel="self" type="application/rss+xml"/><item><title>Dynamically scaling a political news and activism hub (up to 5x the traffic in 20 minutes)</title><link>/talks/dynamically-scaling-a-political-news-and-activism-hub-up-to-5x-the-traffic-in-20-minutes/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate><guid>/talks/dynamically-scaling-a-political-news-and-activism-hub-up-to-5x-the-traffic-in-20-minutes/</guid><description>On any given day this news discussion site can receive traffic peaks up to five times our base traffic, sometimes requiring us to scale out to double our backend app server capacity within a 10-20 minutes window (sometimes at unpredictable times). In this talk, Susan Potter will discuss DailyKos&amp;#39;s use of autoscaling in EC2 from the essential components to some gotchas learned along the way.</description></item><item><title>Functional Operations (Functional Programming at Comcast Labs Connect)</title><link>/talks/functional-operations-functional-programming-at-comcast-labs-connect/</link><pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate><guid>/talks/functional-operations-functional-programming-at-comcast-labs-connect/</guid><description>If we were starting greenfield development of a service or web application today we would likely employ a number of practices and design choices that are known to optimise application responsiveness, resiliency, elasticity, and/or composability. Delivering our reactive applications on top of predictable infrastructure will set our project up for success.
Some of us don&amp;#39;t have that luxury. We must provision, deploy, and operationally maintain legacy monolithic Rails web applications and HTTP APIs that are hard to refactor without introducing new bugs, poorly performing, and struggle to meet user load/peak demand. Built during a prior era of the company where fast and loose practices were rewarded, startup cowboys delivered the first set of features promptly at the expense of subsequent velocity, long-term maintainability, and high risk deployments. When living in this reality, our infrastructure must be reliable or our application needs constant babysitting, leading to on-call fatigue and high staff turnover.
The good news is there are core principles we can apply to produce more reproducible systems, failstop deployments, and consistent environment configurations to eliminate a large class of bugs inherent in legacy applications and minimize related business risks. This will be the focus of the session and applies to both greenfield and legacy cases.
Code examples given using NixOS and Haskell, but focus remains on the underlying principles.</description></item></channel></rss>