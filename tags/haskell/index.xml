<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>haskell on Susan Potter</title><link>/tags/haskell/</link><description>Recent content in haskell on Susan Potter</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 04 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/haskell/index.xml" rel="self" type="application/rss+xml"/><item><title>Profunctors: An API, Part 3</title><link>/software/profunctors-an-api-part-3/</link><pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate><guid>/software/profunctors-an-api-part-3/</guid><description> /images/reflection-small.webp
Photo by Jonatan Pie on Unsplash</description></item><item><title>Profunctors for the web developer: First intuitions, Part 2</title><link>/software/profunctors-for-the-web-developer-first-intuitions-part-2/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><guid>/software/profunctors-for-the-web-developer-first-intuitions-part-2/</guid><description>/images/leaf-half-dead-small.webp
Photo by Mario Dobelmann on Unsplash All of the paired transforms from Part 1 can be modeled with the interface that Profunctor provides but what does that mean and why is that useful?
In Part 2 we will explore our first intuitions about these pairings:
how they are similar to each other
how they are different from each other
how having a common interface for them improves the web developer&amp;#39;s day at work</description></item><item><title>Profunctors for the web developer: Motivating examples, Part 1</title><link>/software/profunctors-for-the-web-developer-motivating-examples-part-1/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>/software/profunctors-for-the-web-developer-motivating-examples-part-1/</guid><description>Offering examples of profunctors that web developers might find motivating.</description></item><item><title>From Zero to Haskell: Lessons Learned (ZuriHac 2019 / Zurich, Switzerland)</title><link>/talks/from-zero-to-haskell-lessons-learned-zurihac-2019-/-zurich-switzerland/</link><pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate><guid>/talks/from-zero-to-haskell-lessons-learned-zurihac-2019-/-zurich-switzerland/</guid><description>Presented at ZuriHac 2019</description></item><item><title>Profunctor exploration in less than 100 lines of Haskell</title><link>/snippets/profunctor-exploration-in-less-than-100-lines-of-haskell/</link><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><guid>/snippets/profunctor-exploration-in-less-than-100-lines-of-haskell/</guid><description>A snippet showing the space around profunctors in Haskell (e.g. Strong, Choice, Cartesian).</description></item><item><title>Parametricity: A Practitioners Guide</title><link>/software/parametricity-a-practitioners-guide/</link><pubDate>Thu, 25 Sep 2014 00:00:00 +0000</pubDate><guid>/software/parametricity-a-practitioners-guide/</guid><description>Introduction What software developer likes surprises, especially in production? Not me. At least not when I am on call. ;)
Wouldn&amp;#39;t it be great if we were able to reason about our code to make our lives as simple as possible when debugging or eliminate debugging altogether?
The big idea of parametricity is that from parametric (or generic) &amp;#34;pure&amp;#34; functions we can determine interesting properties (and more of them) from the parametric (generic) types than the equivalent function fixed with specific types.</description></item><item><title>Functional Algebra: Monoids Applied</title><link>/talks/functional-algebra-monoids-applied/</link><pubDate>Sat, 10 Nov 2012 00:00:00 +0000</pubDate><guid>/talks/functional-algebra-monoids-applied/</guid><description>In functional programming, words from Category Theory are thrown around, but how useful are they really? This session looks at applications of monoids specifically and how using their algebraic properties offers a solid foundation of reasoning in many types of business domains and reduces developer error as computational context complexity increases. This will provide a tiny peak at Category Theory&amp;#39;s practical uses in software development and modeling. Code examples will be in Haskell and Scala, but monoids could be constructed in almost any language by software craftsmen and women utilizing higher orders of reasoning to their code.</description></item></channel></rss>