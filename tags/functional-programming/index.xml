<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>functional programming on Susan Potter</title><link>/tags/functional-programming/</link><description>Recent content in functional programming on Susan Potter</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 10 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/functional-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Converting pattern matches into folds</title><link>/software/converting-pattern-matches-into-folds/</link><pubDate>Sat, 10 Oct 2020 00:00:00 +0000</pubDate><guid>/software/converting-pattern-matches-into-folds/</guid><description/></item><item><title>Dhall's merge keyword and union types</title><link>/snippets/dhalls-merge-keyword-and-union-types/</link><pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate><guid>/snippets/dhalls-merge-keyword-and-union-types/</guid><description>At work my team uses Dhall to generate configuration for services or environments and one thing we often need to do is define union types (also known as sum types).
Pattern matching in Haskell/PureScript background In Haskell and PureScript, we can use a feature of the language called pattern matching to be able to match a particular construction of a sum type value.
For instance, let us start off with a simple special case of a sum type, an enumeration type:</description></item><item><title>Algebraic Data Types in TypeScript</title><link>/software/algebraic-data-types-in-typescript/</link><pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate><guid>/software/algebraic-data-types-in-typescript/</guid><description>Note: the code for the TypeScript (to help you follow along) is available here: Encoding Algebraic Data Types in TypeScript code
Background Recently I&amp;#39;ve been reviewing TypeScript code at work. A common pattern I&amp;#39;ve observed in pull requests and some open source projects is a type that looks like the following:
type FooTag = &amp;#39;Bar&amp;#39; | &amp;#39;Baz&amp;#39; | &amp;#39;Qux&amp;#39;; type Foo&amp;lt;A&amp;gt; = { _tag : FooTag, /* Required for the &amp;#39;Bar&amp;#39; tagged values of Foo */ bar?</description></item><item><title>A quick review of a pure functional serverless application deployed to production</title><link>/software/a-quick-review-of-a-pure-functional-serverless-application-deployed-to-production/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate><guid>/software/a-quick-review-of-a-pure-functional-serverless-application-deployed-to-production/</guid><description>/images/car-dashboard-small.webp
Photo by Dawid Zawi≈Ça on Unsplash This was adapted from a tweet thread on June 3rd, 2020.
Notes:
all references to $ (dollars) is in reference to US Dollars (USD)
latencies are quoted in milliseconds (ms) unless otherwise noted
this serverless application was deployed using the AWS primitives API Gateway (REST) and AWS Lambda
Last week I deployed my second &amp;#34;serverless app&amp;#34; to production.</description></item><item><title>From Zero to Haskell: Lessons Learned (ZuriHac 2019 / Zurich, Switzerland)</title><link>/talks/from-zero-to-haskell-lessons-learned-zurihac-2019-/-zurich-switzerland/</link><pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate><guid>/talks/from-zero-to-haskell-lessons-learned-zurihac-2019-/-zurich-switzerland/</guid><description>Presented at ZuriHac 2019</description></item><item><title>Profunctor exploration in less than 100 lines of Haskell</title><link>/snippets/profunctor-exploration-in-less-than-100-lines-of-haskell/</link><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><guid>/snippets/profunctor-exploration-in-less-than-100-lines-of-haskell/</guid><description>A snippet showing the space around profunctors in Haskell (e.g. Strong, Choice, Cartesian).</description></item><item><title>Functional Operations (Functional Programming at Comcast Labs Connect)</title><link>/talks/functional-operations-functional-programming-at-comcast-labs-connect/</link><pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate><guid>/talks/functional-operations-functional-programming-at-comcast-labs-connect/</guid><description>If we were starting greenfield development of a service or web application today we would likely employ a number of practices and design choices that are known to optimise application responsiveness, resiliency, elasticity, and/or composability. Delivering our reactive applications on top of predictable infrastructure will set our project up for success.
Some of us don&amp;#39;t have that luxury. We must provision, deploy, and operationally maintain legacy monolithic Rails web applications and HTTP APIs that are hard to refactor without introducing new bugs, poorly performing, and struggle to meet user load/peak demand. Built during a prior era of the company where fast and loose practices were rewarded, startup cowboys delivered the first set of features promptly at the expense of subsequent velocity, long-term maintainability, and high risk deployments. When living in this reality, our infrastructure must be reliable or our application needs constant babysitting, leading to on-call fatigue and high staff turnover.
The good news is there are core principles we can apply to produce more reproducible systems, failstop deployments, and consistent environment configurations to eliminate a large class of bugs inherent in legacy applications and minimize related business risks. This will be the focus of the session and applies to both greenfield and legacy cases.
Code examples given using NixOS and Haskell, but focus remains on the underlying principles.</description></item><item><title>Functional and Reactive Operations</title><link>/talks/functional-and-reactive-operations/</link><pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate><guid>/talks/functional-and-reactive-operations/</guid><description>If we were starting greenfield development of a service or web application today we would likely employ a number of practices and design choices that are known to optimise application responsiveness, resiliency, elasticity, and/or composability. Delivering our reactive applications on top of predictable infrastructure will set our project up for success. Some of us don&amp;#39;t have that luxury. We must provision, deploy, and operationally maintain legacy monolithic Rails web applications and HTTP APIs that are hard to refactor without introducing new bugs, poorly performing, and struggle to meet user load/peak demand. Built during a prior era of the company where fast and loose practices were rewarded, startup cowboys delivered the first set of features promptly at the expense of subsequent velocity, long-term maintainability, and high risk deployments. When living in this reality, our infrastructure must be reliable or our application needs constant babysitting, leading to on-call fatigue and high staff turnover. The good news is there are core principles we can apply to produce more reproducible systems, failstop deployments, and consistent environment configurations to eliminate a large class of bugs inherent in legacy applications and minimize related business risks. This will be the focus of the session and applies to both greenfield and legacy cases. Code examples given using NixOS and Haskell, but focus remains on the underlying principles.</description></item><item><title>Put a Type On It: Idris Types as Propositions</title><link>/talks/put-a-type-on-it-idris-types-as-propositions/</link><pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate><guid>/talks/put-a-type-on-it-idris-types-as-propositions/</guid><description>Showing how Curry-Howard can be applied to structuring types to represent logical propositions.</description></item><item><title>Functional Algebra: Monoids Applied</title><link>/talks/functional-algebra-monoids-applied/</link><pubDate>Sat, 10 Nov 2012 00:00:00 +0000</pubDate><guid>/talks/functional-algebra-monoids-applied/</guid><description>In functional programming, words from Category Theory are thrown around, but how useful are they really? This session looks at applications of monoids specifically and how using their algebraic properties offers a solid foundation of reasoning in many types of business domains and reduces developer error as computational context complexity increases. This will provide a tiny peak at Category Theory&amp;#39;s practical uses in software development and modeling. Code examples will be in Haskell and Scala, but monoids could be constructed in almost any language by software craftsmen and women utilizing higher orders of reasoning to their code.</description></item></channel></rss>