<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>software on Susan Potter</title>
    <link>/tags/software/</link>
    <description>Recent content in software on Susan Potter</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Jul 2020 19:12:46 -0500</lastBuildDate>
    
	<atom:link href="/tags/software/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Adding and removing friction to developer process and interaction by design</title>
      <link>/blogs/software/2020/07/growing-good-developer-habits/</link>
      <pubDate>Fri, 17 Jul 2020 19:12:46 -0500</pubDate>
      
      <guid>/blogs/software/2020/07/growing-good-developer-habits/</guid>
      <description>In 2015 I was binge-reading books on how to break bad habits and create good habits. Since then I have been applying the psychology research I learned from those books to my personal habits and also work habits.  When trying to form habits there are four levers that psychology researchers found made forming habits easier:    easy    obvious    This post will describe just two examples from work the last few years that I designed into my teams delivery processes to encourage developers to deliver work assigned to them as soon as possible without them fearing management was constantly monitoring individual metrics and thresholds as they .</description>
    </item>
    
    <item>
      <title>Profunctors: An exploration in less than 100 lines of Haskell</title>
      <link>/blogs/software/2018/10/profunctors/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/blogs/software/2018/10/profunctors/</guid>
      <description>Originally adapted from a gist: https://gist.github.com/mbbx6spp/51bf2b694dc9bbf81b60f2f616453eb3  Profunctors are a remarkably practical abstraction for many activities software developers are concerned with on the day to day.  Consider that much of distributed systems software today concerns the following activity pairs:   Encoding &amp;amp; decoding    We often need to standardize on encoding ensure consistency, e.g. base64 encoding allows us to convert binary data into ASCII without loss, because many systems are more able to deal with ASCII than raw binary data (a legacy decision that we still have to consider today though many new developers do not do this consciously due to lack of context about the purpose of encoding)   Serializing &amp;amp; deserializing    We regularly need to transfer data over the wire and we need to have the client and server have an agreement about how to serialize that data to send and deserialize it when they receive it from the other party, e.</description>
    </item>
    
  </channel>
</rss>