---
layout: post
name: command-line-usability
title: "Command-line Usability"
time: 2014-10-22 20:56:00 -05:00
---

%h3 Why Command-line Usability Matters

%p
  The short answer is because you will enrage the people that use
  the scripts you have written. These people are likely already frustrated
  with their work activities, why inflict more pain and suffering on the
  world?

%p
  %em
    Another, perhaps more compelling (to some) reason is that you might need
    to use your own scripts one day. And you might be sorry. Very sorry if
    you didn't think of command-line usability from the outset.

%p
  The better we, as a profession, improve our focus on all aspects of usability
  the less irritating, less stressful, and more productive our day-to-day
  work existence and balance could become. Isn't that something to strive for?

%h4 The VM Provisioning Script from the Darkest Abyss of Hell

%p
  I came to writing this post because I had to provision some virtual machines
  at work for our new derived metrics monitoring solution. I had previously
  used the script for VM provisioning months before and almost forgot how
  insane it was.

%h5 And then I started provisioning...

%p
  I died a little inside each minute that passed. Not only was the process
  slow, it involved many steps, it had to be run from one specific host
  on your network, which wasn't in a code reviewed repository or maintained
  by any team or collective of relevantly skilled people in the organization
  (read: management failure).

%p
  It was a script initially written in anger, rewritten in frustration and
  then <em>tweaked</em> by many station chefs without an eye for the bigger
  picture or how all the peices should fit together. There was no sous chef
  let along a qualified head chef with the grander vision in mind for the dish.

%p
  Let me stress one thing. This script and all of the scripts it depended on
  was not maanged as living, evolving software in any kind of source
  repository used within the organization. It was just a random sequence of
  bytes on a filesystem under <code>/opt/vmware/bin</code>. I will come back
  to that later, but for now if you aren't horrified by this notion, then you
  should meditate on it or reconsider your profession. Consider the
  implications of
  <a href="http://en.wikipedia.org/wiki/Software_entropy">software entropy</a>
  when software is totally unmanaged like this not to mention the
  organizational risks of potentially losing automation because of a corrupt
  disk.

%p
  Now in this case I am not 100% sure losing the "automated" VM provisioning
  script would have been a bad thing assuming there was (a) a team responsible
  for such things and held accountable for delivering on such a promise and
  (b) that team was actually capable of delivering a worthwhile automation
  for VM provisioning.

%p
  I cannot comment on whether this was or wasn't the case here.
  The rule of it being better to lose heartbreakingly shoddy code when you
  have the relevant team, responsibilities, skillset assigned, and culture
  setup in your organization to rewrite something of limited scope pretty
  much always holds. I stand by this. Fresh canvases after learning
  experiences can be both therapeutic and a force for great good and
  improvement.

%p
  Now this would not have been as traumatic an experience if the script
  automation itself didn't violate some basic tenets of the most basic
  script writing commandments. So let's look at the problems so we can
  better understand usability.

%h4 The Devil's in the Details

%p
  TODO










