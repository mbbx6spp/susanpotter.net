<!doctype html><html lang=en-us><meta charset=utf-8><meta name=template-type content="software"><meta name=template-kind content="page"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel=stylesheet><link rel=stylesheet href=/css/suponet.css integrity><meta name=author content="Susan Potter"><title>Practical Recursion Schemes &ndash; Susan Potter"</title><meta name=description content="An outline of practical use and applications of recursion schemes through examples"><meta name=keywords content="[]"><meta name=theme-color content="#EC4899"><meta name=og:site_name content="Susan Potter"><meta name=og:title content="Practical Recursion Schemes &ndash; Susan Potter"><meta name=og:url content="/software/practical-recursion-schemes/"><meta name=og:description content="An outline of practical use and applications of recursion schemes through examples"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="SusanPotter"><meta name=twitter:creator content="SusanPotter"><meta name=twitter:image content="/images/hat-collage-xs.webp"><meta name=twitter:image:alt content="Susan's avatar wearing many different hats."><meta name=twitter:title content="Practical Recursion Schemes &ndash; Susan Potter"><meta name=twitter:description content="An outline of practical use and applications of recursion schemes through examples"><title>Practical Recursion Schemes &ndash; Susan Potter</title><meta property="og:type" content="website"><link rel=manifest href=/manifest.json><link rel=mask-icon href=/favicon.svg color=#ffffff><link rel=icon href=/favicon.svg><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/apple-touch-icon-precompose.png><body class="text-gray-800 dark:text-gray-200 bg-gray-50 dark:bg-gray-700 mx-auto"><header class="flex flex-col text-gray-600 body-font dark:bg-gray-900"><div class="container mx-auto flex flex-wrap py-6 px-12 flex-col md:flex-row items-center"><a href=/ class="flex title-font font-medium items-center text-gray-700 dark:text-gray-200 mb-4 md:mb-0 hover:no-underline"><h1 class="ml-3 text-2xl font-bold hover:text-black">Susan Potter</h1></a><nav class="md:ml-auto flex flex-wrap items-center text-base justify-center gap-y-2 gap-x-4"><ul class="flex right-0 top-0 p-0 m-0"><li class="flex-1 m-0 py-2 focus:rounded-lg hover:rounded-lg focus:bg-white focus:border focus:border-gray-400 focus:shadow-md hover:bg-white hover:border hover:border-gray-400 hover:shadow-md"><a href=/about/ class="mx-6 py-2 px-4 text-xl text-pink-700 hover:no-underline dark:text-pink-300">About</a></li><li class="flex-1 m-0 py-2 focus:rounded-lg hover:rounded-lg focus:bg-white focus:border focus:border-gray-400 focus:shadow-md hover:bg-white hover:border hover:border-gray-400 hover:shadow-md"><a href=/talks/ class="mx-6 py-2 px-4 text-xl text-pink-700 hover:no-underline dark:text-pink-300">Talks</a></li><li class="flex-1 m-0 py-2 focus:rounded-lg hover:rounded-lg focus:bg-white focus:border focus:border-gray-400 focus:shadow-md hover:bg-white hover:border hover:border-gray-400 hover:shadow-md"><a href=/software/ class="mx-6 py-2 px-4 text-xl text-pink-700 hover:no-underline dark:text-pink-300">Software</a></li><li class="flex-1 m-0 py-2 focus:rounded-lg hover:rounded-lg focus:bg-white focus:border focus:border-gray-400 focus:shadow-md hover:bg-white hover:border hover:border-gray-400 hover:shadow-md"><a href=/snippets/ class="mx-6 py-2 px-4 text-xl text-pink-700 hover:no-underline dark:text-pink-300">Snippets</a></li></ul></nav></div><hgroup class="text-black dark:text-gray-50 container mx-auto px-16 pb-3"><h2 class="text-3xl font-extrabold tracking-wider leading-loose">Practical Recursion Schemes</h2><h3 class="text-gray-800 dark:text-gray-200">Mon October 10, 2018</h3><h4 class="uppercase text-gray-600 dark:text-gray-200 font-bold">DRAFT</h4></hgroup></header><main class="container mt-0 mx-auto px-4 md:px-8 lg:px-16 xl:px-24 2xl:px-32 mb-2 md:mb-4 lg:mb-8 xl:mb-16 2xl:mb-24 rounded-sm border shadow-md border-gray-200 dark:border-gray-600 py-2"><div id=outline-container-headline-1 class=outline-3><h3 id=headline-1>Recursive data types</h3><div id=outline-text-headline-1 class=outline-text-3><p>Recursive data structures pop up all over in software from general-purpose structures
like lists and binary trees to more application-specific structures like this AST from
a simple business rules engine:</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">  data BusinessRule input output
    = IfThenElse (input -&gt; Bool) (BusinessRule input output) (BusinessRule input output)
    | Return (input -&gt; output)
    | Stop</code></pre></div></div></div><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2><code class=verbatim>Functor</code></h3></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3><code class=verbatim>Foldable</code></h3><div id=outline-text-headline-3 class=outline-text-3><p>The <code class=verbatim>Foldable</code> class gives you the ability to process the elements of a structure one-at-a-time, discarding the shape.</p><p>Intuitively this is an assortment of <code class=verbatim>List</code>-like fold methods on other structures</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">class Foldable t where
  foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m
  fold    :: Monoid m =&gt; t m -&gt; m
  foldr   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
  foldl   :: (a -&gt; b -&gt; a) -&gt; a -&gt; t b -&gt; a
  foldr1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
  foldl1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a</code></pre></div><p>Example of defining a <code class=verbatim>Foldable</code> instance manually:</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">data Tree a
  = Empty
  | Leaf a
  | Node (Tree a) (Tree a)

instance Foldable Tree where
  foldMap f Empty = mempty
  foldMap f (Leaf x) = f x
  foldMap f (Node l r) = foldMap f l &lt;&gt; foldMap f r

count :: Foldable t =&gt; t a -&gt; Int
count = getSum . foldMap (const $ Sum 1)</code></pre></div><p><code class=verbatim>Foldable</code> is derivable using the <code class=verbatim>DeriveFoldable</code> language pragma like so:</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">data Tree a
  = Empty
  | Leaf a
  | Node (Tree a) (Tree a)
  deriving (Foldable)</code></pre></div></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Traversable</h3><div id=outline-text-headline-4 class=outline-text-3><p>Traversable gives you the ability to traverse a structure from left-to-right, performing
an effectful action on each element and preserving the shape.</p><ul><li><p>Intuitively it is <code class=verbatim>fmap</code> with effects</p></li><li><p>Derivable using <code class=verbatim>DeriveTraversable</code> language pragma</p></li><li><p>See 'Applicative Progamming with Effects', by McBride and Paterson</p></li></ul><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">class (Functor t, Foldable t) =&gt; Traversable t where
  traverse  :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
  sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)
  mapM      :: Monad m =&gt; (a -&gt; m b) -&gt;  t a -&gt;  m (t a)
  sequence  :: Monad m =&gt; t (m a) -&gt; m (t a)</code></pre></div><p>Example for this for <code class=verbatim>Tree</code> type defining the instance manually is:</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">instance Traversable Tree where
  traverse f Empty = pure Empty
  traverse f (Leaf x) = Leaf &lt;$&gt; f x
  traverse f (Node l r) = Node &lt;$&gt; traverse f l &lt;*&gt; traverse f r</code></pre></div><p>Notes:</p><ul><li><p><code class=verbatim>mapM</code> and <code class=verbatim>sequence</code> generalize Prelude functions of the same name</p></li><li><p><code class=verbatim>sequence</code> can also be thought of as a generalized matrix transpose</p></li></ul><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">sequence :: Monad m =&gt; t (m a) -&gt; m (t a)
sequence = mapM id</code></pre></div></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>Fixed Points of Functors</h3><div id=outline-text-headline-5 class=outline-text-3><p>An idea from category theory which gives:</p><ul><li><p>data-type generic functions</p></li><li><p>compositional data</p></li></ul><p>Fixed points are represented by the type:</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">newtype Fix f = Fix { unFix :: f (Fix f) }</code></pre></div><p>A functor <code class=verbatim>f</code> is a data-type of kind <code class=verbatim>* -> *</code> together with an <code class=verbatim>fmap</code> function.</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">Fix f = f (f (f (f ...</code></pre></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Useful functions</h3><div id=outline-text-headline-6 class=outline-text-3><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>fan-out aka <em>fork</em></h4><div id=outline-text-headline-7 class=outline-text-4><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">(&amp;&amp;&amp;)
  :: (b -&gt; c)
  -&gt; (b -&gt; d)
  -&gt; b
  -&gt; (c, d)
(f &amp;&amp;&amp; g) = \x -&gt; (f x, g x)</code></pre></div></div></div><div id=outline-container-headline-8 class=outline-4><h4 id=headline-8>fan-in</h4><div id=outline-text-headline-8 class=outline-text-4><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">(|||)
  :: (b -&gt; d)
  -&gt; (c -&gt; d)
  -&gt; Either b c
  -&gt; d
(f ||| g) = either</code></pre></div></div></div><div id=outline-container-headline-9 class=outline-4><h4 id=headline-9>function product</h4><div id=outline-text-headline-9 class=outline-text-4><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">(***)
  :: (a -&gt; c)
  -&gt; (b -&gt; d)
  -&gt; (a, b)
  -&gt; (c, d)
(f *** g) = \(x, y) -&gt; (f x, g y)</code></pre></div></div></div><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>generalized unzip for functions</h4><div id=outline-text-headline-10 class=outline-text-4><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">funzip
  :: Functor f
  =&gt; f (a, b)
  -&gt; (f a, f b)
funzip = fmap fst &amp;&amp;&amp; fmap snd</code></pre></div></div></div></div></div><div id=outline-container-headline-11 class=outline-3><h3 id=headline-11>Data-type generic programming</h3><div id=outline-text-headline-11 class=outline-text-3><ul><li><p>allows us to parameterise functions on the structure, or shape, of a data-type</p></li><li><p>useful for large complex data-types, where boilerplate traversal code often dominates,
especially when updating a small subset of constructors</p></li><li><p>for recursion schemes, we can capture the pattern as a standalone combinator</p></li></ul><p>Limitations:</p><ul><li><p>The set of data-types that can be represented by means of <code class=verbatim>Fix</code> is limited to regular data-types.</p></li><li><p>Nested data-types and mutually recursive data-types require higher-order approaches.</p></li></ul><p>In order to work with lists using a data-type generic <code class=verbatim>cata</code> combinator, we need a new "unfixed" type representation.</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">data ListF a r = C a r | N</code></pre></div><p><code class=verbatim>ListF a r</code> is not an ordinary functor, but we can define a polymorphic functor instance for <code class=verbatim>ListF a</code></p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">instance Functor (ListF a) where
  fmap f N = N
  fmap f (C x xs) = C x (f xs)</code></pre></div><p>We might also want a pattern functor for natural numbers!</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">data NatF r = Succ r | Zero deriving Functor</code></pre></div></div></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>Catamorphism</h3><div id=outline-text-headline-12 class=outline-text-3><p>We would like to write <code class=verbatim>foldr</code> once for all data-types.
Category theory shows us how to define it data-type generically for a functor fixed-point.</p><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>That catamorphism-fusion law</h4><div id=outline-text-headline-13 class=outline-text-4><p>The <em>catamorphism-fusion</em> law is arguably the most important law, and can be used to transform
the composition of a function with a catamorphism into a single catamorphism, eliminating
intermediate data structures.</p><div class="src src-haskell -n -r"><pre><code class="language-haskell -n -r" data-lang="haskell -n -r">h . f = g . fmap h =&gt; h . cata f = cata g
  where f :: f a -&gt; a
        g :: f b -&gt; b
        h :: a -&gt; b</code></pre></div></div></div><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>Composing Algebras</h4></div></div></div></main><footer class="flex flex-col bottom-0 left-0 text-gray-600 dark:text-gray-200 body-font w-full mt-8 md:mt-12 lg:mt-16 xl:mt-20"><div class="bg-blue-50 dark:bg-gray-800 text-gray-600 dark:text-gray-200 p-2"><div class="container mx-auto py-4 px-16 flex flex-wrap flex-col sm:flex-row"><p class="text-sm text-center sm:text-left">© 2006 - 2021 Susan Potter —
<a href=https://twitter.com/SusanPotter rel="noopener noreferrer" class=ml-1 aria-hidden=true>@SusanPotter</a></p><span class="inline-flex sm:ml-auto sm:mt-0 mt-2 justify-center sm:justify-start"><a href=https://github.com/mbbx6spp/ class=ml-3 title="mbbx6spp on Github" aria-label="Susan is mbbx6spp on Github"><img src=/images/github.svg width=24 height=24 alt="Github icon"></a>
<a href=https://keybase.io/mbbx6spp class=ml-3 title="mbbx6spp on Keybase" aria-label="Susan is mbbx6spp on Keybase"><img src=/images/keybase.svg width=24 height=24 alt="Keybase icon"></a>
<a href=https://www.linkedin.com/in/susanpotter/ class=ml-3 title="susanpotter on LinkedIn" aria-label="Susan is susanpotter on LinkedIn"><img src=/images/linkedin.svg width=24 height=24 alt="LinkedIn icon"></a>
<a href=https://slideshare.net/mbbx6spp class=ml-3 title="mbbx6spp on Slideshare" aria-label="Susan is mbbx6spp on Slideshare"><img src=/images/slideshare.svg width=24 height=24 alt="Slideshare icon"></a>
<a href=https://twitter.com/SusanPotter class=ml-3 title="SusanPotter on Twitter" aria-label="Susan is SusanPotter on Twitter"><img src=/images/twitter.svg width=24 height=24 alt="Twitter icon"></a></span></div></div></footer></body></html>