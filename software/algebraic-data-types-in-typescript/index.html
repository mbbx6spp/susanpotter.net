<!doctype html><html lang=en-us><meta charset=utf-8><meta name=template-type content="software"><meta name=template-kind content="page"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel=stylesheet><link rel=stylesheet href=/css/suponet.css integrity><meta name=author content="Susan Potter"><title>Algebraic Data Types in TypeScript &ndash; Susan Potter"</title><meta name=description content="Susan Potter is a distributed systems and infrastructure software developer/architect/leader who likes to wear many hats, write strongly typed pure functional programs, and listens to bad pop music."><meta name=keywords content="[]"><meta name=theme-color content><meta name=og:site_name content="Susan Potter"><meta name=og:title content="Algebraic Data Types in TypeScript &ndash; Susan Potter"><meta name=og:url content="/software/algebraic-data-types-in-typescript/"><meta name=og:description content="Susan Potter is a distributed systems and infrastructure software developer/architect/leader who likes to wear many hats, write strongly typed pure functional programs, and listens to bad pop music."><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="SusanPotter"><meta name=twitter:creator content="SusanPotter"><meta name=twitter:image content="/images/hat-collage.webp"><meta name=twitter:image:alt content="Susan's avatar wearing many different hats."><meta name=twitter:title content="Algebraic Data Types in TypeScript &ndash; Susan Potter"><meta name=twitter:description content><title>Algebraic Data Types in TypeScript &ndash; Susan Potter</title><meta property="og:type" content="website"><link rel=manifest href=/manifest.json><body class="text-gray-800 dark:text-gray-200 bg-gray-50 dark:bg-gray-700 mx-auto"><header class="flex flex-col text-gray-600 body-font dark:bg-gray-900"><div class="container mx-auto flex flex-wrap py-6 px-12 flex-col md:flex-row items-center"><a href=/ class="flex title-font font-medium items-center text-gray-700 dark:text-gray-200 mb-4 md:mb-0"><h1 class="ml-3 text-2xl font-bold">Susan Potter</h1></a><nav class="md:ml-auto flex flex-wrap items-center text-base justify-center gap-y-2 gap-x-4"><a href=/about/ class="mx-6 py-2 px-4 text-xl text-pink-600 hover:underline dark:text-pink-500">About</a>
<a href=/talks/ class="mx-6 py-2 px-4 text-xl text-pink-600 hover:underline dark:text-pink-500">Talks</a>
<a href=/software/ class="mx-6 py-2 px-4 text-xl text-pink-600 hover:underline dark:text-pink-500">Software</a>
<a href=/snippets/ class="mx-6 py-2 px-4 text-xl text-pink-600 hover:underline dark:text-pink-500">Snippets</a></nav></div><hgroup class="text-black dark:text-gray-50 container mx-auto px-16 pb-3"><h2 class="text-3xl font-extrabold tracking-wider leading-loose">Algebraic Data Types in TypeScript</h2><h3 class="text-gray-800 dark:text-gray-200">Tue August 8, 2020</h3></hgroup></header><main class="container mt-0 mx-auto px-4 md:px-8 lg:px-16 xl:px-24 2xl:px-32 mb-2 md:mb-4 lg:mb-8 xl:mb-16 2xl:mb-24 rounded-sm border shadow-md border-gray-200 dark:border-gray-600 py-2"><p>Note: the code for the TypeScript (to help you follow along) is
available here: <a href="https://www.typescriptlang.org/play?noUnusedParameters=true#code/MYewdgzgLgBBCmwoEtwHkCuUAOWYF4YAKMAQwFt4YAuOKAJ2TAHMAaGELXKCGmUsAE8A2gF0AlHwBuIZABMCAPhgBvAFAwYoSCAA28AHS6QzIgHJFlyzDMwA1DDKVxAbg0cuWCAfKlsRAA8lLXAIPUNjUwDxV3dtMP0jE3MAHjS0s1jNePCk0zNMtQBfNTUAejKYADFkemgy6FJ6FBYYZCh4elIUcFKoQWwqKpAQABVSZgIbACEm2wAfGdIALwWbAEUMALM3NX7B6pGUgEFlQnVNAH0oCc1aYbGJ1ncygCoYACV4AEcMWvgFAAzED0GBQAAWVDMs3othuzGYAJgUlIugw8F4IEBhxAMFeZXcACMmgB+O50RgsZ6aN6fH5-ehI4GgiFQ2arMETREKFFojEcbEPPEEzTE5ZkvhgDDkQmdakwWlfX7-IEgsGQjZbOFcpG89GYwUjYXuX4BCW0QkjfQCeW0tDYHpkXQwZnqqGbbachG61H6gU442aX5bMm0Y7FPoDKgAYQw9EZYGAgk0+HcZgAqgBlAAiZncizMACkAAoATTzmgLAFF0x8KzAC9GABJVPPlSrHYCgehyJiTKC41kwOQgYDS+BgG6O9gQ5C8Of8MAwACSADkAGrHAAyy+zMBhMAA1kwFFicWp4rBiaD7kdY-GJ0mzqoYNdbrRoXN2GK+ABGABMADMMBFLsFQwKM4ILguAgrhu267vuKxHie-oPBeoRXsht4gCk94Jk+UwqK+8J8J+HIlO2EFQfOvCwWum47nuHowAA7u04KcLAsEgA6qBOjAppBN0DDIISWDwBhkCwKafAPHhcYEYIz7EW+kwfh6ZjsLJtAMOi35NGRADqxyjCStiUeBnbdr2rQDm6w6juOk7dPx6rQXRS4MQhzFbChYCnoaIBUaMTZVtUaBbluaBGWuADiMBVh8HxoB8mbsOmq7RmgACyOVVquowQWgMCZlWVYGO2l6CVs-5yXeimPspRE1UEtCAqiCDaRgfkfiW5YgaU4HLsO8iOCAsCsQIsD2UwDAgHIGDAFQgLYAAtDwYK4oypByJ0vCsZx-CMo48CsVtbRQFRpC8CNU2TkiQ7AmOvD2bKHBLo+C19vwuiIoSXTIMAw7dKQYJRvOYAhVGmbAPQDrfngIK2U0yC6Mmd2cLoCiMlAcZLqtG0QGYvD2o6KTyacygglRVYcZ0JxyHIVbxiC7CU9Ye2DAFP3gGxkKsiyGrAKiug-aAe1UeQyDMOCsBgPAj24r2gKAp0E4oN0VCylArGK59rOgiLCDeFJ0D8EzMK8IQJwwPAAQdAFvAYGAh5gCArFgIoRDXgADPVuGnAZ9C-gHJyKJIOHhw2jgYLozr4MoFwhNJXq8LQ0CUpMhB+wYan2DAABEZSFwX16-nn8JuJoEDsVAwDgsQ8IQJIyfZDdVCFzCZQwoX1DuJoNKVMuS6wWjuhrZe9BLR0CgHnqVBDte-BQKJ4kdDA0uy-LE0D4P4HvQgV6IKQGAIA5y8iYw69UFNmJ8eAqKVYPg+4-jxC58vABkX8wOXBjXkkGSVSpEPwwi0n-QyFomi+wAYZBw-9l5FElHHXQ1dB57Q6nHKAtA370CXFKeO7gSigVKGoBASB+KYBwFgcwu05BWw8DQngEDhDuHoVbIgICJhgK-JA+gH5ITxxAGYIo7BuHMF4bCYOH42IgmxqI8Q8oOFNAgFwkiPCljSMgcsWgAFAIABYxEvjUlIiB14PysQ9hZJR7DLaqPUaYpYqwDK6JgPoox4iNGSK0eYpoljrEgVsRIMh1VyCHgPIQIg6cKR9kjjiBSD5EzNUTsQCRZFwHBz4LwIosQwkROQlEpctApQyk6PE+S+EmpnGUI40Bzi-HLElEEtw+SWJRJ0n-K08AbQ1RDHwKpySKkNSSYRVJ6izBqVsBpLU3UAjdT8rk3Y1VgQgH9oQcJMJzCEl0GDHZpBMitMwi6EYocNkFOWEQDxABWPJxzVl1XOR6Igel4B3NTqs4CTythEA6roLqNgsy5liOQxAjpqHcHMKs5EvoMSsPcKs328pVm-mRSMf8aKQCAWeCEqimZEDgAUO0Torleh7CjEhegdVB7nG8Rkvhy8M6iVaCUfYVB2TUpTCY+p5FGkoLKaCVlFKPT-mjrS-OMzthzL4JacIvTgxmj4McQabKcSitOFMGEdVFgcpjiK8OoTjm13aA3ToUxflGhwqKwZT54mZx+osG1yZFgu0wUwJEqTk7Gvro3C1IBK4TFbnvY2bI5i4PgHjfBNhATIGWKsdB7dz68vDZGpcZhxJxp2MGjumptgpvfqsgwCqE3DngFg3QOCYB4KXK6st7q5DoJIWBSokFahEo6F0R0kYDgwi+dy98vislMqziqil7I+3pN4S4nR-LZSCvJQcD0gExX9vUrmiBnTZXWjAAsxVtBVzgFXKg0gOz4DRyFQcB4y6NWEF7THcdeqtjXsUGQuanQOrLUpQY1d9LtGMtiSytQb76AfvZSsb9k6GmuNnWakowHQMwA9AY6OkGzCaWlRabp8qep7pgAesAR744nv0OehdQwRjIZvV++94HH0BEoy+s2sBNlNG-TbZV9tHZyGdq7d2ntvYxPtSwYZIAGPBDqQOz8f6oFwBaUxzeFy2MwFtpxic3GYAuzdh7L2JAYP0BE2J8ZqH2R8pKXJtpWwlMqYdmpnjWn+NEE3VhndfTcP4cI7s094cDNitqcRSZ8JpnrrmbuuToLKHoE8FAcwww4wQkuiSx08LNAsfoAY7Zuy-6Zf2ZkeULHljpcAr7YrtiUuHiQ78zq8B2BmGjCCR+Uhahn1y+4cJSHElKW9n8hAwSQXgQPedJgvIxpTxnvxV64JuhgggMDRkAArMF3g5ETQAIRUWqlIf2tAYTIadc+VL6X03ZeOwc2I4ENuh22+Bjr1Spj5cK8V32Z3KgbbqrQdre27vlcsykITzAutVZq3V+gDWmvExBbTAIk2z4oEa-0BLnb+JDUqOmRMIByCUEnBfYwwBDw1QmtreAxhzr2QYMmLidsoen2gMgOHyZTW477OUV48nfA+rNVE6FOFduNWSRHbJzLs5J3cN6huxBC1qSDS-ENvj81RpJgIOQWbpc5uTVWiN78zDLD8Mr-eKO0cY41g5YEwj2KtDFgrC6iIZozYuhAJay1HpRgZ8eFge8Kgy7Q1qOXaaAgjHILrptah8RAA">Encoding Algebraic Data Types in TypeScript code</a></p><div id=outline-container-headline-1 class=outline-3><h3 id=headline-1>Background</h3><div id=outline-text-headline-1 class=outline-text-3><p>Recently I've been reviewing TypeScript code at work. A common pattern
I've observed in pull requests and some open source projects is a type
that looks like the following:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FooTag</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Bar&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;Baz&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;Qux&#39;</span>;

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Foo</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>_tag</span>  : <span style=color:#66d9ef>FooTag</span>,
  <span style=color:#75715e>/* Required for the &#39;Bar&#39; tagged values of Foo */</span>
  <span style=color:#a6e22e>bar?</span>  : <span style=color:#66d9ef>string</span>,
  <span style=color:#75715e>/* Required for the &#39;Baz&#39; tagged values of Foo */</span>
  <span style=color:#a6e22e>baz?</span>  : <span style=color:#66d9ef>number</span>,
  <span style=color:#75715e>/* Required for the &#39;Qux&#39; tagged values of Foo */</span>
  <span style=color:#a6e22e>qux?</span>  : <span style=color:#66d9ef>boolean</span>,
  <span style=color:#75715e>/* Optional for the &#39;Qux&#39; tagged values of Foo */</span>
  <span style=color:#a6e22e>quux?</span> : <span style=color:#66d9ef>A</span>
}</code></pre></div></div><p>Notice that <code class=verbatim>Foo</code> is a parameterized type (also called
<a href=https://www.typescriptlang.org/docs/handbook/generics.html>generic type</a>) which means it places a value of type <code class=verbatim>A</code> which is
determined by the caller somewhere in its structure.</p><p>In a business application we might place a <code class=verbatim>Currency</code> enumeration (or
another domain type) that might look like the following:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Currency</span>  <span style=color:#f92672>=</span>
  <span style=color:#e6db74>&#39;USD&#39;</span>
  <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;JPY&#39;</span>
  <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;EUR&#39;</span>
  <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;CHF&#39;</span></code></pre></div></div><p>You might notice that (except for the <code class=verbatim>_tag</code> attribute value) all the
other attributes of type <code class=verbatim>Foo</code> are optionally required to be
present. The above type declaration would allow us to construct the
following values that typecheck against this type:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// According to the documentation, this is an INVALID Bar kind of Foo
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>123</span> };

<span style=color:#75715e>// This is an INVALID Baz kind of Foo
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span> }

<span style=color:#75715e>// This is an INVALID Qux without an optional quxx attribute
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Qux&#39;</span>, <span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>bar</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;WAT?&#39;</span> }

<span style=color:#75715e>// According to the documentation this is an INVALID Qux kind of Foo
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>qux2</span> : <span style=color:#66d9ef>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> { <span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>quux</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;JPY&#39;</span> }</code></pre></div></div><p>Here only the last invalid construction (according to the
documentation) is raised as a type error by TypeScript. All the other
invalid forms of the data get past <code class=verbatim>tsc</code> with no noise being made.</p></div></div><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>Remembering Algebraic Data Types (ADTs)</h3><div id=outline-text-headline-2 class=outline-text-3><p>For the remainder of this blog post, I'll assume you know the basics
of algebraic data types before continuing with this post, but if you
need a refresher, I wrote about <a href=/software/algebraic-data-types/>algebraic data types while ago</a>.</p></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>Inconsistencies of the single record approach</h3><div id=outline-text-headline-3 class=outline-text-3><p>The invalid data constructions above (assuming the documentation is
correct) did not get caught by the <code class=verbatim>tsc</code> typechecker even though the
data was badly constructed. This adds overhead for the developer using
these types as inputs to their functions or outputs from their functions.</p><p>I often see extra logic in utility or combinator functions that
accommodate bad constructions scattered over all the impacted
functions like this:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// I did not want to introduce fp-ts to readers who are new to it
</span><span style=color:#75715e>// as I wanted the focus to be on encoding algebraic data types in
</span><span style=color:#75715e>// TypeScrpt, but ordinarily I would return fp-ts&#39;s Option&lt;Foo&lt;A&gt;&gt; or
</span><span style=color:#75715e>// Either&lt;AddError, Foo&lt;A&gt;&gt; depending on whether the calling code
</span><span style=color:#75715e>// might need to differentiate between error cases.
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>addBars</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>A</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>unknown</span>&gt;(<span style=color:#a6e22e>bar0</span> : <span style=color:#66d9ef>Foo</span>&lt;<span style=color:#f92672>A</span>&gt;, <span style=color:#a6e22e>bar1</span> : <span style=color:#66d9ef>Foo</span>&lt;<span style=color:#f92672>A</span>&gt;) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>=&gt;</span> {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tags</span> : <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>bar0</span>.<span style=color:#a6e22e>_tag</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>bar1</span>.<span style=color:#a6e22e>_tag</span>;
  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>tags</span>) {
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;Bar/Bar&#34;</span><span style=color:#f92672>:</span>
      <span style=color:#75715e>// In an ill-constructed Bar value the bar attribute might not
</span><span style=color:#75715e></span>      <span style=color:#75715e>// be set because the bar attribute was optional.
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>bar0</span>.<span style=color:#a6e22e>bar</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>bar1</span>.<span style=color:#a6e22e>bar</span>) <span style=color:#f92672>?</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>bar0.bar</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>bar1</span>.<span style=color:#a6e22e>bar</span> } <span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>;
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>
  }
};</code></pre></div></div><p>Using this in <code class=verbatim>ts-node</code> we would see:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#75715e>// hits path that returns a new Bar value appending the bar attribute
</span><span style=color:#75715e></span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>addBars</span>({ <span style=color:#a6e22e>_tag</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;hello&#39;</span>}, { <span style=color:#a6e22e>_tag</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39; world&#39;</span>})
{ <span style=color:#e6db74>&#34;_tag&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Bar&#34;</span>, <span style=color:#e6db74>&#34;bar&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;hello world&#34;</span> }

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#75715e>// hits the ternary else null path
</span><span style=color:#75715e></span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>addBars</span>({ <span style=color:#a6e22e>_tag</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>baz</span>: <span style=color:#66d9ef>1234</span>}, { <span style=color:#a6e22e>_tag</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;wow&#39;</span> })
<span style=color:#66d9ef>null</span>

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#75715e>// hits the default path that returns null
</span><span style=color:#75715e></span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>addBars</span>({ <span style=color:#a6e22e>_tag</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span>, <span style=color:#a6e22e>baz</span>: <span style=color:#66d9ef>1234</span>}, { <span style=color:#a6e22e>_tag</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;wow&#39;</span> })
<span style=color:#66d9ef>null</span></code></pre></div></div><p>The clutter in <code class=verbatim>addBars</code> adds up across many functions and is not
isolated to one area of the code or we end up writing partial
functions that ignore bad constructions.</p><p>We could offer clients of our library <em>"smart constructors"</em> which is a
fancy way to say <em>"functions that create well-formed data
constructions"</em>. Something like the following:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mkBar</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>s</span> : <span style=color:#66d9ef>string</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=&gt;</span> ({ <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>s</span> });
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mkBaz</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>n</span> : <span style=color:#66d9ef>number</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=&gt;</span> ({ <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span>, <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>n</span> });
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mkQux</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>boolean</span>, <span style=color:#a6e22e>quux?</span> : <span style=color:#66d9ef>Currency</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=&gt;</span> ({ <span style=color:#e6db74>&#39;_tag&#39;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Qux&#39;</span>, <span style=color:#a6e22e>qux</span>, <span style=color:#a6e22e>quux</span> });</code></pre></div></div><p>We can construct valid data from these smart constructors like so:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>foo0</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkBar</span>(<span style=color:#e6db74>&#39;bla bla&#39;</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>foo1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkBaz</span>(<span style=color:#ae81ff>12345</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>foo2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkQux</span>(<span style=color:#66d9ef>true</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>foo3</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkQux</span>(<span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#39;USD&#39;</span>);</code></pre></div></div><p>All these values get inferred as type <code class=verbatim>Foo</code> as expected (due to the
type annotation for the return type of the smart constructors).</p><p>This certainly helps keep clients of our library construct valid forms
of <code class=verbatim>Foo</code> but the type declaration can still be used by rogue callers
or those that don't bother reading the documentation (myself
included). We could argue about whether it is worth our time nannying
these developers but for the sake of this blog post, I will assume we
want to do the best we can (within reason) to eliminate bad
constructions of type <code class=verbatim>Foo</code> so that we don't need to add extra logic
to our functions that consume these values to check they are
well-formed according to how we intended (read the inline
documentation in the type declaration).</p></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>Native Algebraic Data Types</h3><div id=outline-text-headline-4 class=outline-text-3><p>Stepping back this is how we might define data types in a language
that natively supports algebraic data types satisfying the
documentation's intent.</p><p>Here is a datatype declaration in PureScript:</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Foo</span> a
  <span style=color:#f92672>=</span> <span style=color:#66d9ef>Bar</span> { bar <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> }
  <span style=color:#f92672>|</span> <span style=color:#66d9ef>Baz</span> { baz <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> }
  <span style=color:#f92672>|</span> <span style=color:#66d9ef>Qux</span> { qux <span style=color:#f92672>::</span> <span style=color:#66d9ef>Boolean</span>, quux <span style=color:#f92672>::</span> <span style=color:#66d9ef>Maybe</span> a }</code></pre></div></div><p>What it says is that we have one type named <code class=verbatim>Foo</code> and there are only three
ways we can construct a valid value of <code class=verbatim>Foo</code> according to this type. Namely:</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>foo0</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Bar</span> { bar <span style=color:#66d9ef>:</span> <span style=color:#e6db74>&#34;wowser&#34;</span> }
<span style=color:#a6e22e>foo1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Baz</span> { baz <span style=color:#66d9ef>:</span> <span style=color:#ae81ff>3000</span> }
<span style=color:#a6e22e>foo2</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Qux</span> { qux <span style=color:#66d9ef>:</span> true, quux <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Nothing</span> }</code></pre></div></div><p>Similarly, the application type <code class=verbatim>Currency</code> used in the TypeScript
example looks like this in PureScript:</p><div class="src src-haskell"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Currency</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>USD</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>CHF</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>EUR</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>JPY</span></code></pre></div></div><p>With the declaration of <code class=verbatim>Foo a</code> in PureScript, we are not able to
construct the equivalent to the invalid forms that escaped the
TypeScript typechecker unscathed above.</p><p>Here is us attempting the equivalent of <code class=verbatim>{ _tag : 'Bar', baz : 123
}</code>. It yields the following type error:</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>&gt;&gt;&gt; invalid0 = Bar { baz : 123 }

  Could not match type

    ()

  with type

    ( baz :: Int
    | t0
    )


while trying to match type ()
  with type ( baz :: Int
            | t0
            )
while checking that expression { baz: 123
                               }
  has type { bar :: String
           }
in value declaration invalid0

where t0 is an unknown type</code></pre></div></div><p>Now attempting the PureScript equivalent of <code class=verbatim>{ _tag : 'Baz' }</code> does not
give us a type error but will infer the type as <code class=verbatim>{ baz :: Int } -> Foo
Currency</code>.</p><p>Annotating with the type of <code class=verbatim>Foo Currency</code> yields the following error from the
PureScript typechecker:</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>&gt;&gt;&gt; invalid1 = Baz :: Foo Currency
  Could not match type

    Function
      { baz :: Int
      }

  with type

    Foo


while trying to match type { baz :: Int
                           }
                           -&gt; Foo t0
  with type Foo Currency
while checking that expression Baz
  has type Foo Currency
in value declaration invalid1

where t0 is an unknown type</code></pre></div></div><p>Attempting to do the equivalent of <code class=verbatim>{ _tag : 'Qux', qux : true, bar :
'WAT?' }</code> in PureScript with the sum of products algebraic data type
that describes our intent (based on documentation) yields:</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>&gt;&gt;&gt; invalid2 = Qux { qux : true, bar : &#34;WAT?&#34; }

 Could not match type

    ()

  with type

    ( bar :: String
    | t0
    )


while trying to match type ()
  with type ( bar :: String
            | t0
            )
while checking that expression { qux: true
                               , bar: &#34;WAT?&#34;
                               }
  has type { quux :: Maybe String
           , qux :: Boolean
           }
in value declaration invalid2

where t0 is an unknown type</code></pre></div></div><p>We can already see that describing our <code class=verbatim>Foo a</code> parameterized type in a
sum of products in PureScript keeps our troublesome callers out of
much more trouble than our record-with-many-optional-attributes
encoding in TypeScript at the top.</p></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>TypeScript encodings of non-native algebraic data types</h3><div id=outline-text-headline-5 class=outline-text-3><p>So how can we encode this kind of algebraic data type in
TypeScript which doesn't natively support them (yet)?</p><p>We will explore some of the design space and note the progressive
solution's trade-offs as we go along, attempting to improve on the
faithfulness of the encoding to PureScript's native algebraic data
type's characteristics.</p><p>Our first attempt might be the following:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Bar2</span>    <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>string</span> }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Baz2</span>    <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span>, <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>number</span> }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Qux2</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Qux&#39;</span>, <span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>boolean</span>, <span style=color:#a6e22e>quux?</span> : <span style=color:#66d9ef>A</span> }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Foo2</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>Bar2</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Baz2</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Qux2</span>&lt;<span style=color:#f92672>A</span>&gt;</code></pre></div></div><p>We can then determine which data construction was used via a switch statement like so:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>switcher</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>foo</span> : <span style=color:#66d9ef>Foo2</span>&lt;<span style=color:#f92672>Currency</span>&gt;) <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Currency</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>undefined</span> <span style=color:#f92672>=&gt;</span> {
  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>_tag</span>) {
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;Bar&#39;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;fizz&#39;</span>;
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;Baz&#39;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;buzz&#39;</span>;
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;Qux&#39;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>quux</span>;
    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>undefined</span>;
  }
};</code></pre></div></div><p>We can no longer mix and match attributes that don't correspond to the
data constructor <em>"tag"</em> like we could with the "tagged" single
record. However, we can pass a <code class=verbatim>null</code> value for one of the constructor
arguments instead of giving it the required <code class=verbatim>Currency</code> value
expected. We also probably still want to provide smart
constructors. Also note that we now have four types: <code class=verbatim>Bar</code>, <code class=verbatim>Baz</code>,
<code class=verbatim>Qux</code>, and <code class=verbatim>Foo</code> not just <code class=verbatim>Foo</code>. This point may not be that important
for all library designers.</p><p>However, let's see I we can prevent the nullability of the constructor
attributes:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Bar3</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>string</span> }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Baz3</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span>, <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>number</span> }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Qux3</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Qux&#39;</span>, <span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>boolean</span>, <span style=color:#a6e22e>quux?</span> : <span style=color:#66d9ef>NonNullable</span>&lt;<span style=color:#f92672>A</span>&gt; }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Foo3</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>Bar3</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Baz3</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Qux3</span>&lt;<span style=color:#f92672>A</span>&gt;</code></pre></div></div><p>Note that:</p><ul><li><p>primitive types like <code class=verbatim>string</code>, <code class=verbatim>number</code>, <code class=verbatim>boolean</code> cannot accept a
<code class=verbatim>null</code> value.</p></li><li><p>we only have to specifically annotate the parameterized type for the
optional <code class=verbatim>quuz</code> attribute as <code class=verbatim>NonNullable</code> to get the semantics we
want since it can be anything.</p></li></ul><p>Now if we wanted to eliminate the possibility of constructing a value
of type <code class=verbatim>Bar4</code> instead of unifying all the values under <code class=verbatim>Foo4</code> then we
could update the type declaration like so:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Bar4</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>string</span> }
<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Baz4</span> { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span>, <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>number</span> }
<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Qux4</span>&lt;<span style=color:#f92672>A</span>&gt; { <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Qux&#39;</span>, <span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>boolean</span>, <span style=color:#a6e22e>quux?</span> : <span style=color:#66d9ef>NonNullable</span>&lt;<span style=color:#f92672>A</span>&gt; }
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Foo4</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>Bar4</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Baz4</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Qux4</span>&lt;<span style=color:#f92672>A</span>&gt;

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mkBar4</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>A</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>unknown</span>&gt;(<span style=color:#a6e22e>s</span> : <span style=color:#66d9ef>string</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo4</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=&gt;</span> ({ <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Bar&#39;</span>, <span style=color:#a6e22e>bar</span> : <span style=color:#66d9ef>s</span> });
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mkBaz4</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>A</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>unknown</span>&gt;(<span style=color:#a6e22e>n</span> : <span style=color:#66d9ef>number</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo4</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=&gt;</span> ({ <span style=color:#a6e22e>_tag</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Baz&#39;</span>, <span style=color:#a6e22e>baz</span> : <span style=color:#66d9ef>n</span> });
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mkQux4</span> <span style=color:#f92672>=</span> &lt;<span style=color:#f92672>A</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>unknown</span>&gt;(<span style=color:#a6e22e>qux</span> : <span style=color:#66d9ef>boolean</span>, <span style=color:#a6e22e>quux?</span> : <span style=color:#66d9ef>NonNullable</span>&lt;<span style=color:#f92672>A</span>&gt;) <span style=color:#f92672>:</span> <span style=color:#a6e22e>Foo4</span>&lt;<span style=color:#f92672>A</span>&gt; <span style=color:#f92672>=&gt;</span> ({ <span style=color:#e6db74>&#39;_tag&#39;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Qux&#39;</span>, <span style=color:#a6e22e>qux</span>, <span style=color:#a6e22e>quux</span> });</code></pre></div></div><p>Do not fear, we can still create a <code class=verbatim>Qux4</code> construction of <code class=verbatim>Foo4</code> with
no <code class=verbatim>quux</code> attribute, but if one is given, it cannot be <code class=verbatim>null</code>. This
is our intent based on the original documentation.</p><p>This ensures we don't create values of types <code class=verbatim>Bar4</code>, <code class=verbatim>Baz4</code>, or <code class=verbatim>Qux4</code>
instead of <code class=verbatim>Foo4</code> now giving us the same basic guarantees as
PureScript's sum of products algebraic data type definition for data
construction without pattern matching or exhaustivity checking.</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>mkBar4</span>(<span style=color:#e6db74>&#39;bla bla bla&#39;</span>)
{ <span style=color:#e6db74>&#34;_tag&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Bar&#34;</span>, <span style=color:#e6db74>&#34;bar&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;bla bla bla&#34;</span> }

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>mkBaz4</span>(<span style=color:#ae81ff>3000</span>);
{ <span style=color:#e6db74>&#34;_tag&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Baz&#34;</span>, <span style=color:#e6db74>&#34;baz&#34;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3000</span> }

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>mkQux4</span>(<span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#39;Coronavirus&#39;</span>)
{ <span style=color:#e6db74>&#34;_tag&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Qux&#34;</span>, <span style=color:#e6db74>&#34;qux&#34;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#34;quux&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Coronavirus&#34;</span> }

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#a6e22e>mkQux4</span>&lt;<span style=color:#f92672>MyType</span>&gt;(<span style=color:#66d9ef>false</span>)
{ <span style=color:#e6db74>&#34;_tag&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Qux&#34;</span>, <span style=color:#e6db74>&#34;qux&#34;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span> }</code></pre></div></div><p>The <code class=verbatim>_tag</code> values in each case correspond to the data constructor of
<code class=verbatim>Foo</code> so we can switch on it when we need to but are the types
inferred what we expect (all values infer as <code class=verbatim>Foo</code>)?</p><p>First let's see what happens when we tell the typechecker they should
be <code class=verbatim>Bar4</code>, <code class=verbatim>Baz4</code>, and <code class=verbatim>Qux4</code> respectively.</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>v0</span> : <span style=color:#66d9ef>Bar4</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkBar4</span>(<span style=color:#e6db74>&#39;bla bla bla&#39;</span>);
<span style=color:#a6e22e>Type</span> <span style=color:#e6db74>&#39;Foo4&#39;</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>not</span> <span style=color:#a6e22e>assignable</span> <span style=color:#a6e22e>to</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Bar4&#39;</span>.
  <span style=color:#a6e22e>Property</span> <span style=color:#e6db74>&#39;bar&#39;</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>missing</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Baz4&#39;</span> <span style=color:#a6e22e>but</span> <span style=color:#a6e22e>required</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Bar4&#39;</span>.(<span style=color:#ae81ff>2322</span>)

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>v1</span> : <span style=color:#66d9ef>Baz4</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkBaz4</span>(<span style=color:#ae81ff>3000</span>);
<span style=color:#a6e22e>Type</span> <span style=color:#e6db74>&#39;Foo4&#39;</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>not</span> <span style=color:#a6e22e>assignable</span> <span style=color:#a6e22e>to</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Baz4&#39;</span>.
  <span style=color:#a6e22e>Property</span> <span style=color:#e6db74>&#39;baz&#39;</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>missing</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Bar4&#39;</span> <span style=color:#a6e22e>but</span> <span style=color:#a6e22e>required</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Baz4&#39;</span>.(<span style=color:#ae81ff>2322</span>)

<span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>v2</span> : <span style=color:#66d9ef>Qux4</span>&lt;<span style=color:#f92672>Currency</span>&gt; <span style=color:#f92672>=</span> <span style=color:#a6e22e>mkQux4</span>&lt;<span style=color:#f92672>string</span>&gt;(<span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#39;Coronavirus&#39;</span>);
<span style=color:#a6e22e>Type</span> <span style=color:#e6db74>&#39;Foo4&#39;</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>not</span> <span style=color:#a6e22e>assignable</span> <span style=color:#a6e22e>to</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Qux4&#39;</span>.
  <span style=color:#a6e22e>Property</span> <span style=color:#e6db74>&#39;qux&#39;</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>missing</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Bar4&#39;</span> <span style=color:#a6e22e>but</span> <span style=color:#a6e22e>required</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>type</span> <span style=color:#e6db74>&#39;Qux4&#39;</span>.(<span style=color:#ae81ff>2322</span>)</code></pre></div></div><p>Removing explicit type annotations we see TypeScript infers type
<code class=verbatim>Foo2&lt;A></code> which is ideally what we want for a faithful encoding of a
sum type, which is "closed" (some familiar with JVM
languages may say <em>sealed</em>) over a specified number of data
constructions at time of declaration (it is not extensible later).</p><p>In languages that support algebraic data types natively, like
PureScript and Haskell, the typechecker can do exhaustivity checking
on our pattern matching clauses. This one kind of check early in
development can eliminate a large category of common runtime defects
very early in the development process converting them to compile-time
checks yielding with fast developer feedback. This means the developer
retains their full context of the bugfix or feature being worked on. This is
hugely valuable on several fronts:</p><ul><li><p>developers can fix these partial function problems closer to the
type they were created</p></li><li><p>reduces developer frustration</p></li><li><p>less likely to ship partial logic to environments higher than local
development, saving everyone else's time too.</p></li></ul><p>Next, we will attempt to trick TypeScript into providing exhaustivity
checking for our switch-case statements that we are using as a poor
substitute for pattern matching.</p></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>Can we get <code class=verbatim>tsc</code> to do exhaustivity checking on our <code class=verbatim>_tag</code> switch statements?</h3><div id=outline-text-headline-6 class=outline-text-3><p>In the earlier <code class=verbatim>switch</code> statement, the <code class=verbatim>default</code> branch returned a <code class=verbatim>null</code>
which always irritated me because we had to update our return type to
include <code class=verbatim>null</code>. Now let's remove the <code class=verbatim>return null</code> statement and tighten
the return type to <code class=verbatim>string</code>:</p><div class="src src-typescript"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>matcher</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>foo</span> : <span style=color:#66d9ef>Foo4</span>&lt;<span style=color:#f92672>Currency</span>&gt;) <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=&gt;</span> {
  <span style=color:#66d9ef>switch</span> (<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>_tag</span>) {
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;Bar&#39;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;sand&#39;</span>;
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;Baz&#39;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;zap&#39;</span>;
    <span style=color:#75715e>// Uncomment the following line to get tsc to succeed typechecking
</span><span style=color:#75715e></span>    <span style=color:#75715e>//case &#39;Qux&#39;: return &#39;xoom&#39;;
</span><span style=color:#75715e></span>  }
};</code></pre></div></div><p>When we comment one or more of the possible <code class=verbatim>_tag</code> cases out of our
switch statement the TypeScript compiler gives us the error:</p><div class="src src-text"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Function lacks ending return statement and return type does not include &#39;undefined&#39;.</code></pre></div></div><p>Uncommenting the missing switch statement gives us typechecked code.</p><p>We now have some form of exhaustivity checking from this encoding.</p></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>Alternative encodings of algebraic data types in TypeScript</h3><div id=outline-text-headline-7 class=outline-text-3><p>This is just one way to encode algebraic data types in TypeScript with
the characteristics we care most about and I hope this post gives you
a launchpad to explore the design space further.</p><p>The following are other approaches or explorations that accomplish the
same or similar goals in TypeScript without native algebraic data types:</p><ul><li><p><a href=https://github.com/pfgray/ts-adt>ADTs for typescript, a library</a></p></li><li><p><a href=https://dev.to/piq9117/typescript-button-color-state-with-adts-1755>Typescript - Button Color State with ADTs</a></p></li><li><p><a href=https://www.javiercasas.com/articles/typescript-adts>Improving your React with Typescript ADTs</a></p></li><li><p><a href=https://dev.to/gcanti/functional-design-algebraic-data-types-36kf>Functional design: Algebraic Data Types</a></p></li><li><p><a href=https://blog.carbonfive.com/an-introduction-to-adts-and-structural-pattern-matching-in-typescript/>An Introduction to ADTs and Structural Pattern Matching in TypeScript</a></p></li></ul></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>Parting Thoughts</h3><div id=outline-text-headline-8 class=outline-text-3><p>I hope I've shown that algebraic data types offer developers a
way to build up descriptions of data from the small up to the
very big using the same basic construct.</p><p>Some languages like PureScript (plus Haskell, Fsharp, OCaml) offer a
direct or native encoding of <strong>algebraic data types</strong> (ADTs) that lets
the developer focus on modeling their domain for their application's needs.</p><p>I also demonstrated that even in languages that do not have a direct
or native encoding of algebraic data types we can still describe data
in a compositional way with some extra boilerplate needed to gain the
ideal characteristics of ADTs, specifically in TypeScript.</p><p>My 2012 article about <a href=/software/algebraic-data-types/>Algebraic Data Types</a> showed Scala using an
indirect encoding with sealed traits and case classes that was very
common in Scala2 codebases. Since then Scala3 provides more direct
encodings of ADTs though still not as native as ML-style languages support.</p><p>By building up a rich domain model from smaller ADTs we keep things
compositional which makes it easier for developers to break down
solutions to big problems into smaller parts that can be composed
together without magic or fear and the ability to test and validate
the smaller parts of the solution independently. This helps us keep
our sanity the longer we maintain our codebases.</p><p>Have fun and exploit algebraic data types in your language (or
consider using a language that more directly encodes this idea so you
can worry less about the boilerplate and more about modeling your
application domain).</p></div></div></main><footer class="flex flex-col bottom-0 left-0 text-gray-600 dark:text-gray-200 body-font w-full mt-8 md:mt-12 lg:mt-16 xl:mt-20"><div class="bg-blue-50 dark:bg-gray-800 text-gray-600 dark:text-gray-200 p-2"><div class="container mx-auto py-4 px-16 flex flex-wrap flex-col sm:flex-row"><p class="text-sm text-center sm:text-left"> 2006 - 2021 Susan Potter 
<a href=https://twitter.com/SusanPotter rel="noopener noreferrer" class=ml-1 aria-hidden=true>@SusanPotter</a></p><span class="inline-flex sm:ml-auto sm:mt-0 mt-2 justify-center sm:justify-start"><a href=https://github.com/mbbx6spp/ class=ml-3 title="mbbx6spp on Github" aria-label="Susan is mbbx6spp on Github"><img src=/images/github.svg width=24 height=24 alt="Github icon"></a>
<a href=https://keybase.io/mbbx6spp class=ml-3 title="mbbx6spp on Keybase" aria-label="Susan is mbbx6spp on Keybase"><img src=/images/keybase.svg width=24 height=24 alt="Keybase icon"></a>
<a href=https://www.linkedin.com/in/susanpotter/ class=ml-3 title="susanpotter on LinkedIn" aria-label="Susan is susanpotter on LinkedIn"><img src=/images/linkedin.svg width=24 height=24 alt="LinkedIn icon"></a>
<a href=https://slideshare.net/mbbx6spp class=ml-3 title="mbbx6spp on Slideshare" aria-label="Susan is mbbx6spp on Slideshare"><img src=/images/slideshare.svg width=24 height=24 alt="Slideshare icon"></a>
<a href=https://twitter.com/SusanPotter class=ml-3 title="SusanPotter on Twitter" aria-label="Susan is SusanPotter on Twitter"><img src=/images/twitter.svg width=24 height=24 alt="Twitter icon"></a></span></div></div></footer></body></html>